<!DOCTYPE html>
<html lang="en">
<head>
    <title>Using Sockets and Socket Streams</title>
    <meta http-equiv="X-UA-Compatible" content="IE=7">
    <meta charset="utf-8">
    <meta id="book-resource-type" name="book-resource-type" content="Guide">
    <meta scheme="apple_ref" id="identifier" name="identifier" content="//apple_ref/doc/uid/TP40012488">
	<meta id="document-version" name="document-version" content="1.4.1">
    <meta id="build" name="build" content="084f2df47efca19ba73466924c2bb89d">
    <meta id="chapterId" name="chapterId" content="CH73">
    <meta id="date" name="date" content="2013-09-17">
    <meta id="description" name="description" content="Explains how to perform certain networking tasks that although somewhat common, are beyond the scope of the overview documentation.">
    <meta id="book-title" name="book-title" content="Networking Programming Topics">
    <meta id="book-root" name="book-root" content="../">
    <meta id="book-json" name="book-json" content="../book.json">
    <meta id="devcenter" name="devcenter" content="iOS Dev Center">
    <meta id="devcenter-url" name="devcenter-url" content="http://developer.apple.com/devcenter/ios">
    <meta id="reflib" name="reflib" content="iOS Developer Library">
    <meta id="book-assignments" name="book-assignments" content="{Type/Guide}, {Topic/Networking & Internet}">
    <meta name="pdf" contents="../NetworkingTopics.pdf" /><link id="book-pdf" media="print" rel="alternate" type="application/pdf" href="../NetworkingTopics.pdf" />
    
    <meta id="generator" name="generator" content="Gutenberg 1793d5b6b9">
    <meta name='numbat' content='aa879094b666337fdcde744b62fbff30'>
    <meta id="copyright" name="copyright" content="Copyright 2015 Apple Inc. All Rights Reserved.">
    <meta id="xcode-display" name="xcode-display" content="render">
    <meta id="IndexTitle" name="IndexTitle" content="Networking Programming Topics: Using Sockets and Socket Streams">
    <meta id="resources-uri" name="resources-uri" content="../../../../../Resources/1103">
    <link id="book-index-page" rel="Start" title="Networking Programming Topics" type="text/html" href="../index.html">
    <link id="next-page" rel="Next" type="text/html" href="ResolvingDNSHostnames.html">
    <link id="previous-page" rel="Prev" type="text/html" href="../Introduction/Introduction.html">
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1103/CSS/screen.css">
    
    <!-- xcode_css -->
    <link rel="stylesheet" type="text/css" href="../../../../../Resources/1103/CSS/feedback.css">
</head>    
<body><a name="//apple_ref/doc/uid/CH73" title="Using Sockets and Socket Streams"></a>
    <div id="_omniture_top">
<!-- SiteCatalyst code will be injected here when viewed in production -->
</div>
    <div id="adcHeader" class="hideOnPrint hideInXcode">
        <div id='ssi_Header' class="hideInXcode phone">
            <a id="ssi_LibraryTitle" href='../../../../../navigation/'>iOS Developer Library</a>
            <a id="ssi_AppleDeveloperConnection" href='https://developer.apple.com/'>Developer</a>
            <div id='ssi_SearchButton' role="button" title="Search">Search</div>
        </div>
        <form id='ssi_SearchMenu' method='get' action='../../../../../search/' accept-charset='utf-8'>
            <label for='adcsearch'>Search iOS Developer Library</label>
            <input type='search' id='ssi_SearchField' name='q' accesskey='s' results='5' />
        </form>
    </div>

    <header id="header">
        <div id="title" role="banner">
            <h1>Networking Programming Topics</h1>
            <span id="file_links">
                <a id="PDF_link" role="button" tabindex='4' rel="alternate" title="Download PDF"><span id="pdf_icon"></span>PDF</a>
                <a id="Companion_link" role="button" tabindex='3' title="Download Companion File"><span id="companion_icon"></span>Companion File</a>
            </span>
        </div>
        <ul id="headerButtons" class="hideOnPrint" role="toolbar">
            <li id="toc_button" style="display:none">
                <button tabindex="5" id="table_of_contents" class="open" role="checkbox" aria-label="Show Table of Contents"><span class="disclosure"></span>Table of Contents</button>
            </li>
            <li id="jumpto_button" style="display:none" role="navigation"><select tabindex="6" id="jumpTo"><option value="top">Jump To&#133;</option></select></li>
            <li id="downloadSample_button" style="display:none">
                <a id="Sample_link"><button id="Sample_button">Download Sample Code</button></a>
            </li>
        </ul>
    </header>
    <nav id="tocContainer" tabindex="7">
        <ul id="toc" role="tree"></ul>
    </nav>

    <article id="contents" tabindex="0" role="main">
        <div id="pageNavigationLinks_top" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='ResolvingDNSHostnames.html'>Next</a><a class='previousLink' rel='prev' href='../Introduction/Introduction.html'>Previous</a>
        </div>
        <a id="top" name="top"></a>
        <a id="INDEX" href="../index.html" style="display:none;"></a>
        
        <a name="//apple_ref/doc/uid/CH73-SW1" title="Using Sockets and Socket Streams"></a><h1 id="pageTitle">Using Sockets and Socket Streams</h1><p>This article explains how to work with sockets and socket streams at various levels, from POSIX through Foundation.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/CH73-DontLinkElementID_8" title="Important"></a><p><strong>Important:</strong>&nbsp;This article describes ways to make socket connections that are completely under the control of your program. Most programs would be better served by higher-level APIs such as <code>NSURLConnection</code>. To learn more about these higher-level APIs, read <em><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220" target="_self">Networking Overview</a></em>.</p><p>The APIs described in this article should be used only if you need to support some protocol other than the protocols supported by built-in Cocoa or Core Foundation functionality.</p><p></p></aside></div><p>At almost every level of networking, software can be divided into two categories: clients (programs that connect to other apps) and services (programs that other apps connect to). At a high level, these lines are clear. Most programs written using high-level APIs are purely clients. At a lower level, however, the lines are often blurry.</p><p>Socket and stream programming generally falls into one of the following broad categories:</p><ul class="ul"><li class="li"><p>Packet-based communication—Programs that operate on one packet at a time, listening for incoming packets, then sending packets in reply.</p><p>With packet-based communication, the only differences between clients and servers are the contents of the packets that each program sends and receives, and (presumably) what each program does with the data. The networking code itself is identical.</p></li><li class="li"><p>Stream-based clients—Programs that use TCP to send and receive data as two continuous streams of bytes, one in each direction.</p><p>With stream-based communication, clients and servers are somewhat more distinct. The actual data handling part of clients and servers is similar, but the way that the program initially constructs the communication channel is very different.</p></li></ul><p>This chapter is divided into sections based on the above tasks:</p><ul class="ul"><li class="li"><p><span class="content_text"><a href="#//apple_ref/doc/uid/CH73-SW2">Choosing an API Family</a></span>—Describes how to decide which API family to use when writing networking code.</p></li><li class="li"><p><span class="content_text"><a href="#//apple_ref/doc/uid/CH73-SW4">Writing a TCP-Based Client</a></span>—Describes how to make outgoing TCP connections to existing servers and services.</p></li><li class="li"><p><span class="content_text"><a href="#//apple_ref/doc/uid/CH73-SW8">Writing a TCP-Based Server</a></span>—Describes how to listen for incoming TCP connections when writing servers and services.</p></li><li class="li"><p><span class="content_text"><a href="#//apple_ref/doc/uid/CH73-SW12">Working with Packet-Based Sockets</a></span>—Describes how to work with non-TCP protocols, such as UDP.</p></li></ul><section><a name="//apple_ref/doc/uid/CH73-SW2" title="Choosing an API Family"></a><h2 class="jump">Choosing an API Family</h2><p>The API you choose for socket-based connections depends on whether you are making a connection to another host or receiving a connection from another host. It also depends on whether you are using TCP or some other protocol. Here are a few factors to consider:</p><ul class="ul"><li class="li"><p>In OS X, if you already have networking code that is shared with non-Apple platforms, you can use POSIX C networking APIs and continue to use your networking code as-is (on a separate thread). If your program is based on a Core Foundation or Cocoa (Foundation) run loop, you can also use the Core Foundation <code>CFStream</code> API to integrate the POSIX networking code into your overall architecture on the main thread. Alternatively, if you are using Grand Central Dispatch (GCD), you can add a socket as a dispatch source.</p><p>In iOS, POSIX networking is discouraged because it does not activate the cellular radio or on-demand VPN. Thus, as a general rule, you should separate the networking code from any common data processing functionality and rewrite the networking code using higher-level APIs.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/CH73-SW3" title="Note"></a><p><strong>Note:</strong>&nbsp;If you use POSIX networking code, you should be aware that the POSIX networking API is not protocol-agnostic (you must handle some of the differences between IPv4 and IPv6 yourself). It is a connect-by-IP API rather than a connect-by-name API, which means that you must do a lot of extra work if you want to achieve the same initial-connection performance and robustness that higher-level APIs give you for free. Before you decide to reuse existing POSIX networking code, be sure to read <span class="content_text"><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/CommonPitfalls/CommonPitfalls.html#//apple_ref/doc/uid/TP40010220-CH4-SW20" target="_self">Avoid Resolving DNS Names Before Connecting to a Host</a></span> in <em><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220" target="_self">Networking Overview</a></em>.</p><p></p></aside></div></li><li class="li"><p>For daemons and services that listen on a port, or for non-TCP connections, use POSIX or Core Foundation (<code>CFSocket</code>) C networking APIs.</p></li><li class="li"><p>For client code in Objective-C, use Foundation Objective-C networking APIs. Foundation defines high-level classes for managing URL connections, socket streams, network services, and other networking tasks. It is also the primary non-UI Objective-C framework in OS X and iOS, providing routines for run loops, string handling, collection objects, file access, and so on.</p></li><li class="li"><p>For client code in C, use Core Foundation C networking APIs. The Core Foundation framework and the CFNetwork framework are two of the primary C-language frameworks in OS X and iOS. Together they define the functions and structures upon which the Foundation networking classes are built.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/CH73-SW14" title="Note"></a><p><strong>Note:</strong>&nbsp;In OS X, CFNetwork is a subframework of the Core Services framework; in iOS, CFNetwork is a top-level framework.</p><p></p></aside></div></li></ul></section><section><a name="//apple_ref/doc/uid/CH73-SW4" title="Writing a TCP-Based Client"></a><h2 class="jump">Writing a TCP-Based Client</h2><p>The way you make an outgoing connection depends on what programming language you are using, on the type of connection (TCP, UDP, and so forth), and on whether you are trying to share code with other (non-Mac, non-iOS) platforms.</p><ul class="ul"><li class="li"><p>Use <code>NSStream</code> for outgoing connections in Objective-C.</p><p>If you are connecting to a specific host, create a <code>CFHost</code> object (<em>not </em><code>NSHost</code>—they are not toll-free bridged), then use <code><a href="../../../../CoreFoundation/Reference/CFStreamConstants/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToHost" target="_self">CFStreamCreatePairWithSocketToHost</a></code> or <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToCFHost" target="_self">CFStreamCreatePairWithSocketToCFHost</a></code> to open a socket connected to that host and port and associate a pair of <code>CFStream</code> objects with it. You can then cast these to an <code>NSStream</code> object.</p><p>You can also use the <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToNetService" target="_self">CFStreamCreatePairWithSocketToNetService</a></code> function with a <code><a href="../../../../CoreFoundation/Reference/CFNetServiceRef/index.html#//apple_ref/c/tdef/CFNetServiceRef" target="_self">CFNetServiceRef</a></code> object to connect to a Bonjour service. Read <span class="content_text"><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Discovering,Browsing,AndAdvertisingNetworkServices/Discovering,Browsing,AndAdvertisingNetworkServices.html#//apple_ref/doc/uid/TP40010220-CH9" target="_self">Discovering and Advertising Network Services</a></span> in <em><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220" target="_self">Networking Overview</a></em> for more information.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/CH73-SW20" title="Note"></a><p><strong>Note:</strong>&nbsp;The <code>getStreamsToHost:port:inputStream:outputStream:</code> method of <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSNetService_Class/index.html#//apple_ref/occ/cl/NSNetService" target="_self">NSNetService</a></code> is not available on iOS, and is discouraged on OS X for performance reasons. Specifically, <code>NSNetService</code> requires you to create an instance of <code>NSHost</code>. When you create the object, the lookup is performed synchronously. Thus, it is unsafe to construct an <code>NSHost</code> object on your main application thread. See <em><a href="../../../../../qa/qa1546/_index.html#//apple_ref/doc/uid/DTS40011324" target="_self">NSNetService and Automatic Reference Counting (ARC)</a></em> for details.</p><p></p></aside></div></li><li class="li"><p>Use <code>CFStream</code> for outgoing connections in C.</p><p>If you are writing code that cannot include Objective-C, use the <code>CFStream</code> API. It integrates more easily with other Core Foundation APIs than <code>CFSocket</code>, and enables the cellular hardware on iOS (where applicable), unlike lower-level APIs. You can use <code><a href="../../../../CoreFoundation/Reference/CFStreamConstants/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToHost" target="_self">CFStreamCreatePairWithSocketToHost</a></code> or <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToCFHost" target="_self">CFStreamCreatePairWithSocketToCFHost</a></code> to open a socket connected to a given host and port and associate a pair of <code>CFStream</code> objects with it.</p><p>You can also use the <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToNetService" target="_self">CFStreamCreatePairWithSocketToNetService</a></code> function to connect to a Bonjour service. Read <span class="content_text"><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Discovering,Browsing,AndAdvertisingNetworkServices/Discovering,Browsing,AndAdvertisingNetworkServices.html#//apple_ref/doc/uid/TP40010220-CH9" target="_self">Discovering and Advertising Network Services</a></span> in <em><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220" target="_self">Networking Overview</a></em> for more information.</p></li><li class="li"><p>Use POSIX calls if cross-platform portability is required.</p><p>If you are writing networking code that runs exclusively in OS X and iOS, you should generally avoid POSIX networking calls, because they are harder to work with than higher-level APIs. However, if you are writing networking code that must be shared with other platforms, you can use the POSIX networking APIs so that you can use the same code everywhere.</p><p>Never use synchronous POSIX networking APIs on the main thread of a GUI application. If you use synchronous networking calls in a GUI application, you must do so on a separate thread.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/CH73-SW5" title="Note"></a><p><strong>Note:</strong>&nbsp;POSIX networking does not activate the cellular radio on iOS. For this reason, the POSIX networking API is generally discouraged in iOS.</p><p></p></aside></div></li></ul><p>The subsections below describe the use of <code>NSStream</code>. Except where noted, the <code>CFStream</code> API has functions with similar names, and behaves similarly.</p><p>To learn more about the POSIX socket API, read the UNIX Socket FAQ at <span class="content_text"><a href="http://developerweb.net/" class="urlLink" rel="external">http://developerweb.net/</a></span>.</p><section><a name="//apple_ref/doc/uid/CH73-SW6" title="Establishing a Connection"></a><h3 class="jump">Establishing a Connection</h3><p>As a rule, the recommended way to establish a TCP connection to a remote host is with streams. Streams automatically handle many of the challenges that TCP connections present. For example, streams provide the ability to connect by hostname, and in iOS, they automatically activate a device’s cellular modem or on-demand VPN when needed (unlike <code>CFSocket</code> or BSD sockets). Streams are also a more Cocoa-like networking interface than lower-level protocols, behaving in a way that is largely compatible with the Cocoa file stream APIs.</p><p>The way you obtain input and output streams for a host depends on whether you used service discovery to discover the host:</p><ul class="ul"><li class="li"><p>If you already know the DNS name or IP address of the remote host, obtain Core Foundation read (input) and write (output) streams with the <code><a href="../../../../CoreFoundation/Reference/CFStreamConstants/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToHost" target="_self">CFStreamCreatePairWithSocketToHost</a></code> function. You can then take advantage of the toll-free bridge between <code>CFStream</code> and <code>NSStream</code> to cast your <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/c/tdef/CFReadStreamRef" target="_self">CFReadStreamRef</a></code> and <code><a href="../../../../CoreFoundation/Reference/CFWriteStreamRef/index.html#//apple_ref/c/tdef/CFWriteStreamRef" target="_self">CFWriteStreamRef</a></code> objects to <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSInputStream_Class/index.html#//apple_ref/occ/cl/NSInputStream" target="_self">NSInputStream</a></code> and <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSOutputStream_Class/index.html#//apple_ref/occ/cl/NSOutputStream" target="_self">NSOutputStream</a></code> objects.</p></li><li class="li"><p>If you discovered the host by browsing for network services with a <code>CFNetServiceBrowser</code> object, you obtain input and output streams for the service with the <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocketToNetService" target="_self">CFStreamCreatePairWithSocketToNetService</a></code> function. Read <span class="content_text"><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Discovering,Browsing,AndAdvertisingNetworkServices/Discovering,Browsing,AndAdvertisingNetworkServices.html#//apple_ref/doc/uid/TP40010220-CH9" target="_self">Discovering and Advertising Network Services</a></span> in <em><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220" target="_self">Networking Overview</a></em> for more information.</p></li></ul><p>After you have obtained your input and output streams, you should retain them immediately if you are not using automatic reference counting. Then cast them to <code>NSInputStream</code> and <code>NSOutputStream</code> objects, set their delegate objects (which should conform to the <code><a href="../../../../Cocoa/Reference/NSStreamDelegate_Protocol/index.html#//apple_ref/occ/intf/NSStreamDelegate" target="_self">NSStreamDelegate</a></code> protocol), schedule them on the current run loop, and call their <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/occ/instm/NSStream/open" target="_self">open</a></code> methods.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/CH73-SW7" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are working with more than one connection at a time, you must also keep track of which input stream is associated with a given output stream and vice versa. The most straightforward way to do this is to create your own connection object that holds references to both streams, and then set that object as the delegate for each stream.</p><p></p></aside></div></section><section><a name="//apple_ref/doc/uid/CH73-SW11" title="Handling Events"></a><h3 class="jump">Handling Events</h3><p>When the <code><a href="../../../../Cocoa/Reference/NSStreamDelegate_Protocol/index.html#//apple_ref/occ/intfm/NSStreamDelegate/stream:handleEvent:" target="_self">stream:handleEvent:</a></code> method is called on the <code>NSOutputStream</code> object’s delegate and the <em>streamEvent</em> parameter’s value is <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/c/econst/NSStreamEventHasSpaceAvailable" target="_self">NSStreamEventHasSpaceAvailable</a></code>, call <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSOutputStream_Class/index.html#//apple_ref/occ/instm/NSOutputStream/write:maxLength:" target="_self">write:maxLength:</a></code> to send data. This method returns the number of bytes written or a negative number on error. If fewer bytes were written than you tried to send, you must queue up the remaining data and send it after the delegate method gets called again with an <code>NSStreamEventHasSpaceAvailable</code> event. If an error occurs, you should call <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/occ/instm/NSStream/streamError" target="_self">streamError</a></code> to find out what went wrong.</p><p>When the <code><a href="../../../../Cocoa/Reference/NSStreamDelegate_Protocol/index.html#//apple_ref/occ/intfm/NSStreamDelegate/stream:handleEvent:" target="_self">stream:handleEvent:</a></code> method is called on your <code>NSInputStream</code> object’s delegate and the <em>streamEvent</em> parameter’s value is <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/c/econst/NSStreamEventHasBytesAvailable" target="_self">NSStreamEventHasBytesAvailable</a></code>, your input stream has received data that you can read with the <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSInputStream_Class/index.html#//apple_ref/occ/instm/NSInputStream/read:maxLength:" target="_self">read:maxLength:</a></code> method. This method returns the number of bytes read, or a negative number on error.</p><p>If fewer bytes were read than you need, you must queue the data and wait until you receive another stream event with additional data. If an error occurs, you should call <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/occ/instm/NSStream/streamError" target="_self">streamError</a></code> to find out what went wrong.</p><p>If the other end of the connection closes the connection:</p><ul class="ul"><li class="li"><p>Your connection delegate’s <code>stream:handleEvent:</code> method is called with <code>streamEvent</code> set to <code>NSStreamEventHasBytesAvailable</code>. When you read from that stream, you get a length of zero (<code>0</code>).</p></li><li class="li"><p>Your connection delegate’s <code>stream:handleEvent:</code> method is called with <code>streamEvent</code> set to <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/c/econst/NSStreamEventEndEncountered" target="_self">NSStreamEventEndEncountered</a></code>.</p></li></ul><p>When either of these two events occurs, the delegate method is responsible for detecting the end-of-file condition and cleaning up.</p></section><section><a name="//apple_ref/doc/uid/CH73-SW13" title="Closing the Connection"></a><h3 class="jump">Closing the Connection</h3><p>To close your connection, unschedule it from the run loop, set the connection’s delegate to <code>nil</code> (the delegate is unretained), close both of the associated streams with the <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/occ/instm/NSStream/close" target="_self">close</a></code> method, and then release the streams themselves (if you are not using ARC) or set them to <code>nil</code> (if you are). By default, this closes the underlying socket connection. There are two situations in which you must close it yourself, however:</p><ul class="ul"><li class="li"><p>If you previously set the <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/index.html#//apple_ref/c/data/kCFStreamPropertyShouldCloseNativeSocket" target="_self">kCFStreamPropertyShouldCloseNativeSocket</a></code> to <code>kCFBooleanFalse</code> by calling <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/occ/instm/NSStream/setProperty:forKey:" target="_self">setProperty:forKey:</a></code> on the stream.</p></li><li class="li"><p>If you created the streams based on an existing BSD socket by calling <code><a href="../../../../CoreFoundation/Reference/CFStreamConstants/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocket" target="_self">CFStreamCreatePairWithSocket</a></code>.</p><p>By default, streams created from an existing native socket do not close their underlying socket. However, you can enable automatic closing by setting the <code><a href="../../../../CoreFoundation/Reference/CFSocketStreamRef/index.html#//apple_ref/c/data/kCFStreamPropertyShouldCloseNativeSocket" target="_self">kCFStreamPropertyShouldCloseNativeSocket</a></code> to <code>kCFBooleanTrue</code> with the <code><a href="../../../../Cocoa/Reference/Foundation/Classes/NSStream_Class/index.html#//apple_ref/occ/instm/NSStream/setProperty:forKey:" target="_self">setProperty:forKey:</a></code> method.</p></li></ul></section><section><a name="//apple_ref/doc/uid/CH73-SW15" title="For More Information"></a><h3 class="jump">For More Information</h3><p>To learn more, read <span class="content_text"><a href="../../../../Cocoa/Conceptual/Streams/Articles/NetworkStreams.html#//apple_ref/doc/uid/20002277" target="_self">Setting Up Socket Streams</a></span> in <em><a href="../../../../Cocoa/Conceptual/Streams/Streams.html#//apple_ref/doc/uid/10000188i" target="_self">Stream Programming Guide</a></em>, <em><a href="../../../../../qa/qa1652/_index.html#//apple_ref/doc/uid/DTS40008977" target="_self">Using NSStreams For A TCP Connection Without NSHost</a></em>, or see the <em><a href="../../../../../samplecode/SimpleNetworkStreams/Introduction/Intro.html#//apple_ref/doc/uid/DTS40008979" target="_self">SimpleNetworkStreams</a></em> and <em><!--a target="_self" -->RemoteCurrency<!--/a--></em> sample code projects.</p></section></section><section><a name="//apple_ref/doc/uid/CH73-SW8" title="Writing a TCP-Based Server"></a><h2 class="jump">Writing a TCP-Based Server</h2><p>As mentioned previously, a server and a client are similar once the connection is established. The main difference is that clients make outgoing connections, whereas servers create a <em class="newTerm">listening socket</em> (sometimes listen socket)—a socket that listens for incoming connections—then accept connections on that socket. After that, each resulting connection behaves just like a connection you might make in a client.</p><p>The API you should choose for your server depends primarily on whether you are trying to share the code with other (non-Mac, non-iOS) platforms. There are only two APIs that provide the ability to listen for incoming network connections: the Core Foundation socket API and the POSIX (BSD) socket API. Higher-level APIs cannot be used for accepting incoming connections.</p><ul class="ul"><li class="li"><p>If you are writing code for OS X and iOS exclusively, use POSIX networking calls to set up your network sockets. Then, use GCD or <code>CFSocket</code> to integrate the sockets into your run loop.</p></li><li class="li"><p>Use pure POSIX networking code with a POSIX-based run loop (<code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/select.2.html#//apple_ref/doc/man/2/select" target="_self">select</a></code>) if cross-platform portability with non-Apple platforms is required.</p><p>If you are writing networking code that runs exclusively in OS X and iOS, you should generally avoid POSIX networking calls because they are harder to work with than higher level APIs. However, if you are writing networking code that must be shared with other platforms, you can use the POSIX networking APIs so that you can use the same code everywhere.</p></li><li class="li"><p>Never use <code>NSSocketPort</code> or <code>NSFileHandle</code> for general socket communication. For details, see <span class="content_text"><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/CommonPitfalls/CommonPitfalls.html#//apple_ref/doc/uid/TP40010220-CH4-SW3" target="_self">Do Not Use NSSocketPort (OS X) or NSFileHandle for General Socket Communication</a></span> in <em><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220" target="_self">Networking Overview</a></em>.</p></li></ul><p>The following sections describe how to use these APIs to listen for incoming connections.</p><section><a name="//apple_ref/doc/uid/CH73-SW9" title="Listening with Core Foundation"></a><h3 class="jump">Listening with Core Foundation</h3><p>To use Core Foundation APIs to listen for incoming connections, you must do the following:</p><ol class="ol"><li class="li"><p>Add appropriate includes:</p><div class="codesample clear"><table><tr><td scope="row"><pre>#include &lt;CoreFoundation/CoreFoundation.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;sys/socket.h&gt;<span></span></pre></td></tr><tr><td scope="row"><pre>#include &lt;netinet/in.h&gt;<span></span></pre></td></tr></table></div></li><li class="li"><p>Create socket objects (returned as a <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketRef" target="_self">CFSocketRef</a></code> object) with the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketCreate" target="_self">CFSocketCreate</a></code> or <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketCreateWithNative" target="_self">CFSocketCreateWithNative</a></code> function. Specify <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/econst/kCFSocketAcceptCallBack" target="_self">kCFSocketAcceptCallBack</a></code> as the <code>callBackTypes</code> parameter value. Provide a pointer to a <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketCallBack" target="_self">CFSocketCallBack</a></code> callback function as the <em>callout</em> parameter value.</p><div class="codesample clear"><table><tr><td scope="row"><pre>CFSocketRef myipv4cfsock = CFSocketCreate(<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    PF_INET,<span></span></pre></td></tr><tr><td scope="row"><pre>    SOCK_STREAM,<span></span></pre></td></tr><tr><td scope="row"><pre>    IPPROTO_TCP,<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFSocketAcceptCallBack, handleConnect, NULL);<span></span></pre></td></tr><tr><td scope="row"><pre>CFSocketRef myipv6cfsock = CFSocketCreate(<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    PF_INET6,<span></span></pre></td></tr><tr><td scope="row"><pre>    SOCK_STREAM,<span></span></pre></td></tr><tr><td scope="row"><pre>    IPPROTO_TCP,<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFSocketAcceptCallBack, handleConnect, NULL);<span></span></pre></td></tr></table></div></li><li class="li"><p>Bind a socket with the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketSetAddress" target="_self">CFSocketSetAddress</a></code> function. Provide a <code>CFData</code> object containing a <code>sockaddr</code> struct that specifies information about the desired port and family.</p><div class="codesample clear"><table><tr><td scope="row"><pre>struct sockaddr_in sin;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>memset(&amp;sin, 0, sizeof(sin));<span></span></pre></td></tr><tr><td scope="row"><pre>sin.sin_len = sizeof(sin);<span></span></pre></td></tr><tr><td scope="row"><pre>sin.sin_family = AF_INET; /* Address family */<span></span></pre></td></tr><tr><td scope="row"><pre>sin.sin_port = htons(0); /* Or a specific port */<span></span></pre></td></tr><tr><td scope="row"><pre>sin.sin_addr.s_addr= INADDR_ANY;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFDataRef sincfd = CFDataCreate(<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    (UInt8 *)&amp;sin,<span></span></pre></td></tr><tr><td scope="row"><pre>    sizeof(sin));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFSocketSetAddress(myipv4cfsock, sincfd);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(sincfd);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>struct sockaddr_in6 sin6;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>memset(&amp;sin6, 0, sizeof(sin6));<span></span></pre></td></tr><tr><td scope="row"><pre>sin6.sin6_len = sizeof(sin6);<span></span></pre></td></tr><tr><td scope="row"><pre>sin6.sin6_family = AF_INET6; /* Address family */<span></span></pre></td></tr><tr><td scope="row"><pre>sin6.sin6_port = htons(0); /* Or a specific port */<span></span></pre></td></tr><tr><td scope="row"><pre>sin6.sin6_addr = in6addr_any;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFDataRef sin6cfd = CFDataCreate(<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    (UInt8 *)&amp;sin6,<span></span></pre></td></tr><tr><td scope="row"><pre>    sizeof(sin6));<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFSocketSetAddress(myipv6cfsock, sin6cfd);<span></span></pre></td></tr><tr><td scope="row"><pre>CFRelease(sin6cfd);<span></span></pre></td></tr></table></div></li><li class="li"><p>Begin listening on a socket by adding the socket to a run loop.</p><p>Create a run-loop source for a socket with the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketCreateRunLoopSource" target="_self">CFSocketCreateRunLoopSource</a></code> function. Then, add the socket to a run loop by providing its run-loop source to the  <code><a href="../../../../CoreFoundation/Reference/CFRunLoopRef/index.html#//apple_ref/c/func/CFRunLoopAddSource" target="_self">CFRunLoopAddSource</a></code> function.</p><div class="codesample clear"><table><tr><td scope="row"><pre>CFRunLoopSourceRef socketsource = CFSocketCreateRunLoopSource(<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    myipv4cfsock,<span></span></pre></td></tr><tr><td scope="row"><pre>    0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopAddSource(<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopGetCurrent(),<span></span></pre></td></tr><tr><td scope="row"><pre>    socketsource,<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFRunLoopDefaultMode);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopSourceRef socketsource6 = CFSocketCreateRunLoopSource(<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    myipv6cfsock,<span></span></pre></td></tr><tr><td scope="row"><pre>    0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopAddSource(<span></span></pre></td></tr><tr><td scope="row"><pre>    CFRunLoopGetCurrent(),<span></span></pre></td></tr><tr><td scope="row"><pre>    socketsource6,<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFRunLoopDefaultMode);<span></span></pre></td></tr></table></div></li></ol><p>After this, you can access the underlying BSD socket descriptor with the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketGetNative" target="_self">CFSocketGetNative</a></code> function.</p><p>When you are through with the socket, you must close it by calling <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketInvalidate" target="_self">CFSocketInvalidate</a></code>.</p><p>In your listening socket’s callback function (<code>handleConnect</code> in this case), you should check to make sure the value of the <em>callbackType</em> parameter is <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/econst/kCFSocketAcceptCallBack" target="_self">kCFSocketAcceptCallBack</a></code>, which means that a new connection has been accepted. In this case, the <em>data</em> parameter of the callback is a pointer to a <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketNativeHandle" target="_self">CFSocketNativeHandle</a></code> value (an integer socket number) representing the socket.</p><p>To handle the new incoming connections, you can use the <code>CFStream</code>, <code>NSStream</code>, or <code>CFSocket</code> APIs. The stream-based APIs are strongly recommended.</p><p>To do this:</p><ol class="ol"><li class="li"><p>Create read and write streams for the socket with the <code><a href="../../../../CoreFoundation/Reference/CFStreamConstants/index.html#//apple_ref/c/func/CFStreamCreatePairWithSocket" target="_self">CFStreamCreatePairWithSocket</a></code> function.</p></li><li class="li"><p>Cast the streams to an <code>NSInputStream</code> object and an <code>NSOutputStream</code> object if you are working in Cocoa.</p></li><li class="li"><p>Use the streams as described in <span class="content_text"><a href="#//apple_ref/doc/uid/CH73-SW4">Writing a TCP-Based Client</a></span>.</p></li></ol><p>For more information, see <em><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/doc/uid/20001445" target="_self">CFSocket Reference</a></em>. For sample code, see the <em><!--a target="_self" -->RemoteCurrency<!--/a--></em> and <em><a href="../../../../../samplecode/WiTap/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007321" target="_self">WiTap</a></em> sample code projects.</p></section><section><a name="//apple_ref/doc/uid/CH73-SW10" title="Listening with POSIX Socket APIs"></a><h3 class="jump">Listening with POSIX Socket APIs</h3><p>POSIX networking is fairly similar to the <code>CFSocket</code> API, except that you have to write your own run-loop-handling code.</p><div class="importantbox clear"><aside><a name="//apple_ref/doc/uid/CH73-DontLinkElementID_9" title="Important"></a><p><strong>Important:</strong>&nbsp;Never use POSIX networking APIs on the main thread of a GUI application. If you use POSIX networking in a GUI application, you must either do so on a separate thread or use GCD.</p><p></p></aside></div><p>Here are the basic steps for creating a POSIX-level server:</p><ol class="ol"><li class="li"><p>Create a socket by calling <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/socket.2.html#//apple_ref/doc/man/2/socket" target="_self">socket</a></code>. For example:</p><div class="codesample clear"><table><tr><td scope="row"><pre>int ipv4_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);<span></span></pre></td></tr><tr><td scope="row"><pre>int ipv6_socket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);<span></span></pre></td></tr></table></div></li><li class="li"><p>Bind it to a port.</p><ul class="ul"><li class="li"><p>If you have a specific port in mind, use that.</p></li><li class="li"><p>If you don’t have a specific port in mind, pass zero for the port number, and the operating system will assign you an ephemeral port. (If you are going to advertise your service with Bonjour, you should almost always use an ephemeral port.)</p></li></ul><p>For example:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    struct sockaddr_in sin;<span></span></pre></td></tr><tr><td scope="row"><pre>    memset(&amp;sin, 0, sizeof(sin));<span></span></pre></td></tr><tr><td scope="row"><pre>    sin.sin_len = sizeof(sin);<span></span></pre></td></tr><tr><td scope="row"><pre>    sin.sin_family = AF_INET; // or AF_INET6 (address family)<span></span></pre></td></tr><tr><td scope="row"><pre>    sin.sin_port = htons(0);<span></span></pre></td></tr><tr><td scope="row"><pre>    sin.sin_addr.s_addr= INADDR_ANY;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>    if (bind(listen_sock, (struct sockaddr *)&amp;sin, sizeof(sin)) &lt; 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Handle the error.<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr></table></div></li><li class="li"><p>If you are using an ephemeral port, call <code>getsockname</code> to find out what port you are using. You can then register this port with Bonjour. For example:</p><div class="codesample clear"><table><tr><td scope="row"><pre>    socklen_t len = sizeof(sin);<span></span></pre></td></tr><tr><td scope="row"><pre>    if (getsockname(listen_sock, (struct sockaddr *)&amp;sin, &amp;len) &lt; 0) {<span></span></pre></td></tr><tr><td scope="row"><pre>        // Handle error here<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    // You can now get the port number with ntohs(sin.sin_port).<span></span></pre></td></tr></table></div></li><li class="li"><p>Call <code>listen</code> to begin listening for incoming connections on that port.</p></li></ol><p>The next steps depend on whether you intend to use pure POSIX socket code or a higher level abstraction.</p><section><a name="//apple_ref/doc/uid/CH73-SW16" title="Handling Events with Core Foundation"></a><h4 class="jump">Handling Events with Core Foundation</h4><p>Call <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketCreateWithNative" target="_self">CFSocketCreateWithNative</a></code>. Then follow the directions in <span class="content_text"><a href="#//apple_ref/doc/uid/CH73-SW9">Listening with Core Foundation</a></span>, beginning at step 3.</p></section><section><a name="//apple_ref/doc/uid/CH73-SW17" title="Handling Events with Grand Central Dispatch"></a><h4 class="jump">Handling Events with Grand Central Dispatch</h4><p>GCD allows you to perform operations asynchronously, and provides an event queue mechanism for determining when to read data from the socket. After creating the listening socket, a GCD-based server should:</p><ol class="ol"><li class="li"><p>Call <code><!--a target="_self" -->dispatch_source_create<!--/a--></code> to create a dispatch source for the listening socket, specifying <code>DISPATCH_SOURCE_TYPE_READ</code> as the source type.</p></li><li class="li"><p>Call <code><!--a target="_self" -->dispatch_source_set_event_handler<!--/a--></code> (or <code><!--a target="_self" -->dispatch_source_set_event_handler_f<!--/a--></code> and <code><!--a target="_self" -->dispatch_set_context<!--/a--></code>) to set a handler that gets called whenever a new connection arrives on the socket.</p></li><li class="li"><p>When the listen socket handler is called (upon a new connection), it should:</p><ul class="ul"><li class="li"><p>Call <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/accept.2.html#//apple_ref/doc/man/2/accept" target="_self">accept</a></code>. This function fills a new <code>sockaddr</code> structure with information about the connection and returns a new socket for that connection.</p><p>If desired, call <code>ntohl(my_sockaddr_obj.sin_addr.s_addr)</code> to determine the client’s IP address.</p></li><li class="li"><p>Call <code><!--a target="_self" -->dispatch_source_create<!--/a--></code> to create a dispatch source for the client socket, specifying <code>DISPATCH_SOURCE_TYPE_READ</code> as the source type.</p></li><li class="li"><p>Call <code>setsockopt</code> to set the <code>SO_NOSIGPIPE</code> flag on the socket.</p></li><li class="li"><p>Call <code><!--a target="_self" -->dispatch_source_set_event_handler<!--/a--></code> (or <code><!--a target="_self" -->dispatch_source_set_event_handler_f<!--/a--></code> and <code><!--a target="_self" -->dispatch_set_context<!--/a--></code>) to set a handler that gets called whenever the state of the connection changes.</p></li></ul></li><li class="li"><p>In the client socket handler, call <code><!--a target="_self" -->dispatch_async<!--/a--></code> or <code><!--a target="_self" -->dispatch_async_f<!--/a--></code> and pass a block that calls <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/read.2.html#//apple_ref/doc/man/2/read" target="_self">read</a></code> on the socket to grab any new data, then handle that data appropriately. This block can also send responses by calling <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/write.2.html#//apple_ref/doc/man/2/write" target="_self">write</a></code> on the socket.</p></li></ol></section><section><a name="//apple_ref/doc/uid/CH73-SW18" title="Handling Events with Pure POSIX Code"></a><h4 class="jump">Handling Events with Pure POSIX Code</h4><ol class="ol"><li class="li"><p>Create a file descriptor set and add new sockets to that set as new connections come in.</p><div class="codesample clear"><table><tr><td scope="row"><pre>fd_set incoming_connections;<span></span></pre></td></tr><tr><td scope="row"><pre>memset(&amp;incoming_connections, 0, sizeof(incoming_connections));<span></span></pre></td></tr></table></div></li><li class="li"><p>If you need to perform actions periodically on your networking thread, construct a <code>timeval</code> structure for the <code>select</code> timeout.</p><div class="codesample clear"><table><tr><td scope="row"><pre>    struct timeval tv;<span></span></pre></td></tr><tr><td scope="row"><pre>    tv.tv_sec = 1; /* 1 second timeout */<span></span></pre></td></tr><tr><td scope="row"><pre>    tv.tv_usec = 0; /* no microseconds. */<span></span></pre></td></tr></table></div><p>It is important to choose a timeout that is reasonable. Short timeout values bog down the system by causing your process to run more frequently than is necessary. Unless you are doing something very unusual, your <code>select</code> loop should not wake more than a few times per second, at most, and on iOS, you should try to avoid doing this at all. For alternatives, read <span class="content_text"><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/CommonPitfalls/CommonPitfalls.html#//apple_ref/doc/uid/TP40010220-CH4-SW2" target="_self">Avoid POSIX Sockets and CFSocket on iOS Where Possible</a></span> in <em><a href="../../../../NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010220" target="_self">Networking Overview</a></em>.</p><p>If you do not need to perform periodic actions, pass <code>NULL</code>.</p></li><li class="li"><p>Call <code>select</code> in a loop, passing <em>two separate copies</em> of that file descriptor set (created by calling <code>FD_COPY</code>) for the read and write descriptor sets. The <code>select</code> system call modifies these descriptor sets, clearing any descriptors that are not ready for reading or writing.</p><p>For the <code>timeout</code> parameter, pass the <code>timeval</code> structure you created earlier. Although OS X and iOS do not modify this structure, some other operating systems replace this value with the amount of time remaining. Thus, for cross-platform compatibility, you must reset this value each time you call <code>select</code>.</p><p>For the <code>nfds</code> parameter, pass a number that is one higher than the highest-numbered file descriptor that is actually in use.</p></li><li class="li"><p>Read data from sockets, calling <code>FD_ISSET</code> to determine if a given socket has pending data.</p><p>Write data to calling <code>FD_ISSET</code> to determine if a given socket has room for new data.</p><p>Maintain appropriate queues for incoming and outgoing data.</p></li></ol><p>As an alternative to the POSIX <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/select.2.html#//apple_ref/doc/man/2/select" target="_self">select</a></code> function, the BSD-specific <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/kqueue.2.html#//apple_ref/doc/man/2/kqueue" target="_self">kqueue</a></code> API can also be used to handle socket events.</p></section><section><a name="//apple_ref/doc/uid/CH73-SW19" title="For More Information"></a><h4 class="jump">For More Information</h4><p>To learn more about POSIX networking, read the <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/socket.2.html#//apple_ref/doc/man/2/socket" target="_self">socket</a></code>, <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/listen.2.html#//apple_ref/doc/man/2/listen" target="_self">listen</a></code>, <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/FD_SET.2.html#//apple_ref/doc/man/2/FD_SET" target="_self">FD_SET</a></code>, and <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/select.2.html#//apple_ref/doc/man/2/select" target="_self">select</a></code> manual pages.</p></section></section></section><section><a name="//apple_ref/doc/uid/CH73-SW12" title="Working with Packet-Based Sockets"></a><h2 class="jump">Working with Packet-Based Sockets</h2><p>The recommended way to send and receive UDP packets is by combining the POSIX API and either the <code>CFSocket</code> or GCD APIs. To use these APIs, you must perform the following steps:</p><ol class="ol"><li class="li"><p>Create a socket by calling <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/socket.2.html#//apple_ref/doc/man/2/socket" target="_self">socket</a></code>.</p></li><li class="li"><p>Bind the socket by calling <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/bind.2.html#//apple_ref/doc/man/2/bind" target="_self">bind</a></code>. Provide a <code>sockaddr</code> struct that specifies information about the desired port and family.</p></li><li class="li"><p>Connect the socket by calling <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/connect.2.html#//apple_ref/doc/man/2/connect" target="_self">connect</a></code> (optional).</p><p>Note that a connected UDP socket is not a connection in the purest sense of the word. However, it provides two advantages over an unconnected socket. First, it removes the need to specify the destination address every time you send a new message. Second, your app <em>may</em> receive errors when a packet cannot be delivered. This error delivery is not guaranteed with UDP, however; it is dependent on network conditions that are beyond your app’s control.</p></li></ol><p>From there, you can work with the connection in three ways:</p><ul class="ul"><li class="li"><p>If you are using GCD for run loop integration (recommended), create a dispatch source by calling <code><!--a target="_self" -->dispatch_source_create<!--/a--></code>. Assign an event handler to the dispatch source. Optionally assign a cancellation handler. Finally, pass the dispatch source to the <code><!--a target="_self" -->dispatch_resume<!--/a--></code> function to begin handling events.</p></li><li class="li"><p>If you are using <code>CFSocket</code> for integration, this technique is somewhat more complicated, but makes it easier to interface your code with some Cocoa APIs. However, <code>CFSocket</code> objects use a single object to represent a connection (much like sockets at the POSIX layer), whereas most Cocoa APIs are designed to interface with stream-based APIs that use separate objects for sending and receiving. As a result, some Cocoa APIs that expect read or write streams may be difficult to use in conjunction with <code>CFSocketRef</code> objects.</p><p>To use <code>CFSocket</code>:</p><ol class="ol"><li class="li"><p>Create an object to use for managing the connection. If you are writing Objective-C code, this can be a class. If you are writing pure C code, this should be a Core Foundation object, such as a mutable dictionary.</p></li><li class="li"><p>Create a context object to describe that object.</p><div class="codesample clear"><table><tr><td scope="row"><pre>CFSocketContext ctxt;<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>ctxt.version = 0;<span></span></pre></td></tr><tr><td scope="row"><pre>ctxt.info = my_context_object;<span></span></pre></td></tr><tr><td scope="row"><pre>ctxt.retain = CFRetain;<span></span></pre></td></tr><tr><td scope="row"><pre>ctxt.release = CFRelease;<span></span></pre></td></tr><tr><td scope="row"><pre>ctxt.copyDescription = NULL;<span></span></pre></td></tr></table></div></li><li class="li"><p>Create a <code>CFSocket</code> object (<code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketRef" target="_self">CFSocketRef</a></code>) for the <code>CFSocketNativeHandle</code> object by calling <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketCreateWithNative" target="_self">CFSocketCreateWithNative</a></code>.</p><p>Be sure to set (at minimum) the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/econst/kCFSocketDataCallBack" target="_self">kCFSocketDataCallBack</a></code> flag in your <code>callBackTypes</code> parameter value. <em>Do not</em> set the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/econst/kCFSocketAcceptCallBack" target="_self">kCFSocketAcceptCallBack</a></code> flag.</p><p>You’ll also need to provide a pointer to a <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/tdef/CFSocketCallBack" target="_self">CFSocketCallBack</a></code> callback function as the <em>callout</em> parameter value.</p><p>For example:</p><div class="codesample clear"><table><tr><td scope="row"><pre>CFSocketRef connection = CFSocketCreateWithNative(kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    sock,<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFSocketDataCallBack,<span></span></pre></td></tr><tr><td scope="row"><pre>    handleNetworkData,<span></span></pre></td></tr><tr><td scope="row"><pre>    &amp;ctxt);<span></span></pre></td></tr></table></div></li><li class="li"><p>Tell Core Foundation that it is allowed to close the socket when the underlying Core Foundation object is invalidated.</p><div class="codesample clear"><table><tr><td scope="row"><pre>CFOptionFlags sockopt = CFSocketGetSocketFlags(connection);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>sockopt |= kCFSocketCloseOnInvalidate | kCFSocketAutomaticallyReenableReadCallBack;<span></span></pre></td></tr><tr><td scope="row"><pre>CFSocketSetSocketFlags(connection, sockopt);<span></span></pre></td></tr></table></div></li><li class="li"><p>Create an event source for the socket and schedule it on your run loop.</p><div class="codesample clear"><table><tr><td scope="row"><pre>CFRunLoopSourceRef socketsource = CFSocketCreateRunLoopSource(<span></span></pre></td></tr><tr><td scope="row"><pre>    kCFAllocatorDefault,<span></span></pre></td></tr><tr><td scope="row"><pre>    connection,<span></span></pre></td></tr><tr><td scope="row"><pre>    0);<span></span></pre></td></tr><tr><td scope="row"><pre> <span></span></pre></td></tr><tr><td scope="row"><pre>CFRunLoopAddSource(CFRunLoopGetCurrent(), socketsource, kCFRunLoopDefaultMode);<span></span></pre></td></tr></table></div></li></ol><p>Whenever new data becomes available, the data handler callback gets called. In your callback, if the value of the <em>callbackType</em> parameter is <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/econst/kCFSocketConnectCallBack" target="_self">kCFSocketConnectCallBack</a></code>, check the <em>data</em> parameter passed into the callback. If it is <code>NULL</code>, you have connected to the host. You can then send data using the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketSendData" target="_self">CFSocketSendData</a></code> function.</p><p>When you are finished with the socket, close and invalidate it by calling the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketInvalidate" target="_self">CFSocketInvalidate</a></code> function.</p><p>At any point, you can also access the underlying BSD socket by calling the <code><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/c/func/CFSocketGetNative" target="_self">CFSocketGetNative</a></code> function.</p><p>For more information, see <em><a href="../../../../CoreFoundation/Reference/CFSocketRef/index.html#//apple_ref/doc/uid/20001445" target="_self">CFSocket Reference</a></em>. For sample code, see the <em><!--a target="_self" -->UDPEcho<!--/a--></em> sample code project.</p></li><li class="li"><p>If you are using pure POSIX sockets, use the <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/select.2.html#//apple_ref/doc/man/2/select" target="_self">select</a></code> system call to wait for data, then use the <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/read.2.html#//apple_ref/doc/man/2/read" target="_self">read</a></code> and <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/write.2.html#//apple_ref/doc/man/2/write" target="_self">write</a></code> system calls to perform I/O. To learn more about sending and receiving UDP packets with the POSIX socket API, read the UNIX Socket FAQ at <span class="content_text"><a href="http://developerweb.net/" class="urlLink" rel="external">http://developerweb.net/</a></span>.</p></li></ul></section><section><a name="//apple_ref/doc/uid/CH73-SW21" title="Obtaining the Native Socket Handle for a Socket Stream"></a><h2 class="jump">Obtaining the Native Socket Handle for a Socket Stream</h2><p>Sometimes when working with socket-based streams (<code>NSInputStream</code>, <code>NSOutputStream</code>, <code>CFReadStream</code>, or <code>CFWriteStream</code>), you may need to obtain the underlying socket handle associated with a stream. For example, you might want to find out the IP address and port number for each end of the stream with <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/getsockname.2.html#//apple_ref/doc/man/2/getsockname" target="_self">getsockname</a></code> and <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/getpeername.2.html#//apple_ref/doc/man/2/getpeername" target="_self">getpeername</a></code>, or set socket options with <code><a href="../../../../System/Conceptual/ManPages_iPhoneOS/man2/setsockopt.2.html#//apple_ref/doc/man/2/setsockopt" target="_self">setsockopt</a></code>.</p><p>To obtain the native socket handle for an input stream, call the following method:</p><div class="codesample clear"><table><tr><td scope="row"><pre>-(int) socknumForNSInputStream: (NSStream *)stream<span></span></pre></td></tr><tr><td scope="row"><pre>{<span></span></pre></td></tr><tr><td scope="row"><pre>    int sock = -1;<span></span></pre></td></tr><tr><td scope="row"><pre>    NSData *sockObj = [stream propertyForKey:<span></span></pre></td></tr><tr><td scope="row"><pre>               (__bridge NSString *)kCFStreamPropertySocketNativeHandle];<span></span></pre></td></tr><tr><td scope="row"><pre>    if ([sockObj isKindOfClass:[NSData class]] &amp;&amp;<span></span></pre></td></tr><tr><td scope="row"><pre>         ([sockObj length] == sizeof(int)) ) {<span></span></pre></td></tr><tr><td scope="row"><pre>        const int *sockptr = (const int *)[sockObj bytes];<span></span></pre></td></tr><tr><td scope="row"><pre>        sock = *sockptr;<span></span></pre></td></tr><tr><td scope="row"><pre>    }<span></span></pre></td></tr><tr><td scope="row"><pre>    return sock;<span></span></pre></td></tr><tr><td scope="row"><pre>}<span></span></pre></td></tr></table></div><p>You can do the same thing with an output stream, but you only need to do this with one or the other because the input and output streams for a given connection always share the same underlying native socket.</p><div class="notebox"><aside><a name="//apple_ref/doc/uid/CH73-SW24" title="Note"></a><p><strong>Note:</strong>&nbsp;If you are working with a Core Foundation stream, you can do the same thing with <code><a href="../../../../CoreFoundation/Reference/CFReadStreamRef/index.html#//apple_ref/c/func/CFReadStreamCopyProperty" target="_self">CFReadStreamCopyProperty</a></code>, <code><a href="../../../../CoreFoundation/Reference/CFDataRef/index.html#//apple_ref/c/func/CFDataGetLength" target="_self">CFDataGetLength</a></code>, and <code><a href="../../../../CoreFoundation/Reference/CFDataRef/index.html#//apple_ref/c/func/CFDataGetBytes" target="_self">CFDataGetBytes</a></code>.</p><p></p></aside></div></section>
        <div id="pageNavigationLinks_bottom" class="pageNavigationLinks">
            <a class='nextLink' rel='next' href='ResolvingDNSHostnames.html'>Next</a><a class='previousLink' rel='prev' href='../Introduction/Introduction.html'>Previous</a>
        </div><br/>
        <div class="copyright"><br/><hr /><div align="center"><p class="content_text" lang="en" dir="ltr"> Copyright &#x00a9; 2013 Apple Inc. All Rights Reserved. <a href="http://www.apple.com/legal/internet-services/terms/site.html" target="_blank">Terms of Use</a>   |  <a href="http://www.apple.com/privacy/" target="_blank">Privacy Policy</a>  |  Updated: 2013-09-17</p></div></div>

        <div id="pediaWindow">
            <div id="pediaHeader"></div>
            <div id="pediaBody"></div>
        </div>
    </article>

    <div id="blackout">
    <div id="preload"></div>
</div>
<div id="leave_feedback" class="button" role="button" tabindex="0">Feedback</div>
<div id="modal" aria-hidden="true">
    <div id="closebox" tabindex="0" aria-label="Close feedback form" role="button"></div>
    <div id="sending" class="hidden">
        <h2 tabindex="0">Sending feedback&hellip;</h2>
        <div id="sending_img"></div>
    </div>
    <div id="error" class="hidden">
        <h2 tabindex="0">We&rsquo;re sorry, an error has occurred.</h2>
        <p>Please try submitting your feedback later.</p>
        <div id="error_icon"></div>
    </div>
    <div id="success" class="hidden">
        <h2 tabindex="0">Thank you for providing feedback!</h2>
        <p>Your input helps improve our developer documentation.</p>
        <div id="thank_you_icon"></div>
    </div>
    
    <form id="feedback" action="#" method="post">
        <div class="left-leaf">
            <h2 id="helpful_title" data-asterisk="a1" tabindex="0">How helpful is this document?</h2>     
            <sup id="a1" class="asterisk" aria-hidden="true">*</sup>

            <div id="star_group" role="radiogroup" aria-required="true">
                <label> 
                    <input class="radio" type="radio" name="helped" value="1" /> 
                    Very helpful
                </label>
                <label> 
                    <input class="radio" type="radio" name="helped" value="2" /> 
                    Somewhat helpful
                </label>
                <label>
                    <input class="radio" type="radio" name="helped" value="3" /> 
                    Not helpful
                </label>
            </div>
        </div>
        <div class="right-leaf">
            <h2>How can we improve this document?</h2>
            <div id="improve" class="checkboxes">
                <label>
                    <input type="checkbox" name="typo" /> 
                    Fix typos or links
                </label>
                <label>
                    <input type="checkbox" name="infoIncorrect" /> 
                    Fix incorrect information
                </label>
                <label>
                    <input type="checkbox" name="needs_examples" /> 
                    Add or update code samples
                </label>
                <label>
                    <input type="checkbox" name="needs_art" /> 
                    Add or update illustrations
                </label>
                <label>
                    <input type="checkbox" name="missingInfo" /> 
                    Add information about...
                </label>
            </div>
        </div>

        <textarea id="comment" name="problem" cols="70" rows="8" placeholder="Please tell us more about your experience with this document" data-asterisk="a2" required></textarea>
        <sup id="a2" class="asterisk" aria-hidden="true">*</sup>

        <input id="email" type="email" name="email" placeholder="Email (optional)" size="48">

        <p class="fineprint">
            <em aria-hidden="true"><span>*</span> Required information</em>
        </p> 

        <input id="submit" type="button" value="Send" />

        <section id="legal">
            <p>
                To submit a product bug or enhancement request, please visit the 
                <a href="https://developer.apple.com/bugreporter/" target="_blank">Bug Reporter</a> 
                page.
            </p>
            <p>
                Please read <a href="http://www.apple.com/legal/policies/ideas.html" target="_blank">Apple's Unsolicited Idea Submission Policy</a> 
                before you send us your feedback.
            </p> 
        </section>
    </form>
</div>

    
    <script charset="utf-8" src="../../../../../Resources/1103/JavaScript/lib/prototype.js"></script>
    <script src="../../../../../Resources/1103/JavaScript/library.js"></script>
    <script src="../../../../../Resources/1103/JavaScript/feedback.js"></script>
</body>
<script type="text/javascript" src="/library/webstats/pagetracker.js"></script>
<script type="text/javascript">
if(typeof PageTracker !== 'undefined') {
  if(window.addEventListener) {
    window.addEventListener("load", function(){PageTracker.logPageLoad()},false);
  } else if(window.attachEvent) {
    window.attachEvent("onload",function(){PageTracker.logPageLoad()});
  }
}
</script>
</html>
